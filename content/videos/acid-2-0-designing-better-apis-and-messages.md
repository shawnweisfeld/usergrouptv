---
title: "ACID 2.0: Designing Better APIs and Messages"
date: 2020-05-14T12:03:20.0000000
draft: false
---

{{< vimeo 422571386 >}}

## Speaker:

 - Michael L Perry

## Abstract:

<p>Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That's fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don't all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.</p>

## Bio:

 - <p>Michael travels through space clinging to the carbon hull of a spherical ship made of molten iron. He commands an army of microorganisms which decompose the molecules that he captures to provide chemical energy for his cells. His mission is to increase entropy throughout the universe. Michael wrote The Art of Immutable Architecture, a book on applying mathematics to building distributed systems. Learn more at https://immutablearchitecture.com. In his spare time, he records Pluralsight courses on CQRS, XAML Patterns, Cryptography, and Provable Code. Formerly a Microsoft MVP for seven years. He maintains the spoon-bending Assisticant, Correspondence, and Jinaga open-source libraries. He shared videos about distributed systems at historicalmodeling.com. And he helps his clients at Improving benefit from the power of software mathematics. Software is math. Every class is a theorem. The compiler is the proof. And unit tests check our work.</p>

## Recorded At:

 - Tulsa .NET User Group

