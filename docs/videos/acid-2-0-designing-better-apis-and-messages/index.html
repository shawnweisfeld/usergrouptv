<!DOCTYPE html>
<html lang="en">
    <meta charset="utf-8"><script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https:\/\/usergroup.tv\/"
        },
        "articleSection" : "videos",
        "name" : "ACID 2.0: Designing Better APIs and Messages",
        "headline" : "ACID 2.0: Designing Better APIs and Messages",
        "description" : "\u003cp\u003eDatabases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That\u0027s fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don\u0027t all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.\u003c\/p\u003e",
        "inLanguage" : "en",
        "author" : "Shawn Weisfeld",
        "creator" : "Shawn Weisfeld",
        "publisher": "Shawn Weisfeld",
        "accountablePerson" : "Shawn Weisfeld",
        "copyrightHolder" : "Shawn Weisfeld",
        "copyrightYear" : "2020",
        "datePublished": "2020-05-14T12:03:20Z",
        "dateModified" : "2020-05-14T12:03:20Z",
        "url" : "\/videos\/acid-2-0-designing-better-apis-and-messages\/",
        "wordCount" : "0",
        "keywords" : [ "ACID","Blog" ]
    }
</script>
<title>
    ACID 2.0: Designing Better APIs and Messages &ndash; UserGroup.tv
</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="&lt;p&gt;Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That&#39;s fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don&#39;t all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.&lt;/p&gt;">
<meta name="author" content="Shawn Weisfeld">
<link rel="icon" href="/favicon.ico">


<meta itemprop="name" content="ACID 2.0: Designing Better APIs and Messages">
<meta itemprop="description" content="&lt;p&gt;Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That&#39;s fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don&#39;t all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.&lt;/p&gt;"><meta itemprop="datePublished" content="2020-05-14T12:03:20+00:00" />
<meta itemprop="dateModified" content="2020-05-14T12:03:20+00:00" />
<meta itemprop="wordCount" content="0"><meta itemprop="image" content="https://i.vimeocdn.com/video/898661059-3df616acf473c246d544bb9f5e2e7a6d3fd33e33261e40fc65f7832f47607ded-d_295x166">
<meta itemprop="keywords" content="ACID," />
<meta property="og:title" content="ACID 2.0: Designing Better APIs and Messages" />
<meta property="og:description" content="&lt;p&gt;Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That&#39;s fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don&#39;t all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.&lt;/p&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://usergroup.tv/videos/acid-2-0-designing-better-apis-and-messages/" /><meta property="og:image" content="https://i.vimeocdn.com/video/898661059-3df616acf473c246d544bb9f5e2e7a6d3fd33e33261e40fc65f7832f47607ded-d_295x166" /><meta property="article:section" content="videos" />
<meta property="article:published_time" content="2020-05-14T12:03:20+00:00" />
<meta property="article:modified_time" content="2020-05-14T12:03:20+00:00" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.vimeocdn.com/video/898661059-3df616acf473c246d544bb9f5e2e7a6d3fd33e33261e40fc65f7832f47607ded-d_295x166"/>

<meta name="twitter:title" content="ACID 2.0: Designing Better APIs and Messages"/>
<meta name="twitter:description" content="&lt;p&gt;Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That&#39;s fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don&#39;t all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.&lt;/p&gt;"/>


<link rel="alternate" href="/index.xml" type="application/rss+xml" title="UserGroup.tv"/>










<link rel="stylesheet" href="/css/vendor.min.bfce43db53ea1b06d2bb16511e9b733eb4aefaf130b53804b253a4f9bf9f0702e2c08227c6ebbce6b4b537d898593af583d5fb1da9557104d61005dd624588d5.css" integrity="sha512-v85D21PqGwbSuxZRHptzPrSu&#43;vEwtTgEslOk&#43;b&#43;fBwLiwIInxuu85rS1N9iYWTr1g9X7HalVcQTWEAXdYkWI1Q==">



  <meta property="og:image:secure" content="https://i.vimeocdn.com/video/898661059-3df616acf473c246d544bb9f5e2e7a6d3fd33e33261e40fc65f7832f47607ded-d_295x166" />
<body><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4">
    <div class="container">
        <a class="navbar-brand" href="/">
            <img src="/images/Ugtv.png" alt="UserGroup.tv">
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/videos/category/speaker/">Speakers</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/videos/category/group/">Groups</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/videos/tag/">Tags</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/about-us/">About Us</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://forms.office.com/Pages/ResponsePage.aspx?id=TlyBc-0-d0WrTt-gYiae0KLqSn4LXatBuXAR729jgnhUQ0MyQUlFMEw5UTdUMVI1TDQ1M0RFNElTSC4u" target="_blank">Publish</a>
            </li>
          </ul>
        </div>
    </div>
</nav>      
<main role="main">

    <div data-type="ad" data-publisher="lqm.usergrouptv.site" data-format="728x90" data-zone="ros" class="horizontal-ad"></div>

    <div class="container mt-3 mb-3">

        <h1>
            ACID 2.0: Designing Better APIs and Messages
        </h1>

        <div class="addthis_inline_share_toolbox text-right"></div>

        
        <iframe src="https://player.vimeo.com/video/422571386" width="100%" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
        


        <h2>Abstract: </h2>
        <div><p>Databases uphold 4 promises. Transactions are Atomic, Consistent, Isolated, and Durable. That's fine for the small, directly-connected scope of a database, but what about distributed systems? How can we ensure correctness across APIs and message queues? When we cross compute boundaries, we need a different set of promises. We need to know that the system will behave correctly when messages arrive out of order. It needs the ability to retry on delivery failure without causing duplication. And we must be sure that all nodes converge even if they don't all subscribe to the same queues. We need ACID 2.0. A system that is ACID 2.0 is: Associative, Commutative, Idempotent, and Distributed. Each of these guarantees is vital for the correct behavior of a system. And better yet, they provide guidance for designing Web APIs and service bus messages. They are precisely defined, so that we can verify with certainty whether the systems we build uphold these promises, or whether we are setting ourselves up for failure. Build better Web applications, mobile apps, and microservices. Make them resilient. Make them ACID 2.0.</p></div>

        <h2>Speakers: </h2>
        <div>
            <ul>
                
                <li>
                    <h3>
                        <a href="/videos/category/speaker/michael-l-perry">Michael L Perry</a>
                    </h3>
                    <div>
<span class="badge badge-primary">23 Recordings</span>

</div>
                    <div>Software is math. Every class is a theorem. The compiler is the proof. And unit tests check our work. Michael wrote The Art of Immutable Architecture, a book on applying mathematics to building distributed systems. Learn more at https://immutablearchitecture.com. Michael has recorded Pluralsight courses on Distributed Systems, XAML Patterns, and Cryptography, in addition to Provable Code. Formerly a Microsoft MVP for seven years, he maintains the spoon-bending Assisticant and Jinaga open-source libraries. You can find his videos about distributed systems at historicalmodeling.com. And he helps his clients at Improving benefit from the power of software mathematics.</div>
                </li>
                
            </ul>            
        </div>

        <h2>Recorded At: </h2>
        <div>
            <ul>
                
                <li>
                    <a href="/videos/category/group/tulsa-net-user-group">Tulsa .NET User Group</a> 
<span class="badge badge-primary">37 Recordings</span>


                </li>
                
            </ul>            
        </div>

        <h2>Recorded on: </h2>
        <div>May 14, 2020</div>

        <h2>More Info: </h2>
        <div><a href="https://www.meetup.com/TulsaDevelopers-net/events/270482468/" target="_blank" >https://www.meetup.com/TulsaDevelopers-net/events/270482468/</a></div>

        <h2>Tags: </h2>
        <div>
            <ul>
                
                <li>
                    <a href="/videos/tag/acid">ACID</a> 
<span class="badge badge-primary">1 Recording</span>


                </li>
                
            </ul>            
        </div>


    </div>


        </main>

<nav class="navbar navbar-expand-sm navbar-dark bg-dark">
    <div class="container">
        <div class="collapse navbar-collapse" id="navbarCollapse">
        <span class="navbar-text">
            &copy; UserGroup.tv 2020
        </span>
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
                <a class="nav-link" href="/privacy-policy">Privacy Policy</a>
            </li>
        </ul>
        </div>
    </div>
</nav>



<script src="/js/vendor.min.0b95d4b13b8eff7c0d7bd03abfa2dfec4c3a2691c28074f3d11165fabb257bbe8fe13a9ea0be599db9df9fb80f3bf18323f1153786cd4cb1c383b06d58ed99a1.js" integrity="sha512-C5XUsTuO/3wNe9A6v6Lf7Ew6JpHCgHTz0RFl&#43;rsle76P4TqeoL5Znbnfn7gPO/GDI/EVN4bNTLHDg7BtWO2ZoQ=="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-155341911-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script type='text/javascript'>
    function _dmBootstrap(file) {
        var _dma = document.createElement('script');
        _dma.type = 'text/javascript';
        _dma.async = true;
        _dma.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + file;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(_dma);
    }
    function _dmFollowup(file) { if (typeof DMAds === 'undefined') _dmBootstrap('cdn2.DeveloperMedia.com/a.min.js'); }
    (function () { _dmBootstrap('cdn1.DeveloperMedia.com/a.min.js'); setTimeout(_dmFollowup, 2000); })();
</script>

<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5fb843a02f2efdea"></script>
</body>
</html>
