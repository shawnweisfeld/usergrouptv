<!DOCTYPE html>
<html lang="en">
    <meta charset="utf-8"><script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https:\/\/usergroup.tv\/"
        },
        "articleSection" : "videos",
        "name" : "Continuous Testing With React, Storybook, and WebdriverIO",
        "headline" : "Continuous Testing With React, Storybook, and WebdriverIO",
        "description" : "\u003cp\u003eWorking in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.\u003c\/p\u003e",
        "inLanguage" : "en",
        "author" : "Shawn Weisfeld",
        "creator" : "Shawn Weisfeld",
        "publisher": "Shawn Weisfeld",
        "accountablePerson" : "Shawn Weisfeld",
        "copyrightHolder" : "Shawn Weisfeld",
        "copyrightYear" : "2017",
        "datePublished": "2017-10-06T22:29:44Z",
        "dateModified" : "2017-10-06T22:29:44Z",
        "url" : "\/videos\/continuous-testing-with-react-storybook-and-webdriverio\/",
        "wordCount" : "0",
        "keywords" : [ "Testing","Blog" ]
    }
</script>
<title>
    Continuous Testing With React, Storybook, and WebdriverIO &ndash; UserGroup.tv
</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="&lt;p&gt;Working in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.&lt;/p&gt;">
<meta name="author" content="Shawn Weisfeld">
<link rel="icon" href="/favicon.ico">


<meta itemprop="name" content="Continuous Testing With React, Storybook, and WebdriverIO">
<meta itemprop="description" content="&lt;p&gt;Working in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.&lt;/p&gt;"><meta itemprop="datePublished" content="2017-10-06T22:29:44+00:00" />
<meta itemprop="dateModified" content="2017-10-06T22:29:44+00:00" />
<meta itemprop="wordCount" content="0"><meta itemprop="image" content="https://i.vimeocdn.com/video/660062710-7a2e27ce8fe7ae2b50e89085723fa8f712de4bcd94e7bfe3ae1efed7531cf889-d_295x166">
<meta itemprop="keywords" content="Testing," />
<meta property="og:title" content="Continuous Testing With React, Storybook, and WebdriverIO" />
<meta property="og:description" content="&lt;p&gt;Working in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.&lt;/p&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://usergroup.tv/videos/continuous-testing-with-react-storybook-and-webdriverio/" /><meta property="og:image" content="https://i.vimeocdn.com/video/660062710-7a2e27ce8fe7ae2b50e89085723fa8f712de4bcd94e7bfe3ae1efed7531cf889-d_295x166" /><meta property="article:section" content="videos" />
<meta property="article:published_time" content="2017-10-06T22:29:44+00:00" />
<meta property="article:modified_time" content="2017-10-06T22:29:44+00:00" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.vimeocdn.com/video/660062710-7a2e27ce8fe7ae2b50e89085723fa8f712de4bcd94e7bfe3ae1efed7531cf889-d_295x166"/>

<meta name="twitter:title" content="Continuous Testing With React, Storybook, and WebdriverIO"/>
<meta name="twitter:description" content="&lt;p&gt;Working in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.&lt;/p&gt;"/>


<link rel="alternate" href="/index.xml" type="application/rss+xml" title="UserGroup.tv"/>










<link rel="stylesheet" href="/css/vendor.min.bfce43db53ea1b06d2bb16511e9b733eb4aefaf130b53804b253a4f9bf9f0702e2c08227c6ebbce6b4b537d898593af583d5fb1da9557104d61005dd624588d5.css" integrity="sha512-v85D21PqGwbSuxZRHptzPrSu&#43;vEwtTgEslOk&#43;b&#43;fBwLiwIInxuu85rS1N9iYWTr1g9X7HalVcQTWEAXdYkWI1Q==">



  <meta property="og:image:secure" content="https://i.vimeocdn.com/video/660062710-7a2e27ce8fe7ae2b50e89085723fa8f712de4bcd94e7bfe3ae1efed7531cf889-d_295x166" />
<body><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4">
    <div class="container">
        <a class="navbar-brand" href="/">
            <img src="/images/Ugtv.png" alt="UserGroup.tv">
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/videos/category/speaker/">Speakers</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/videos/category/group/">Groups</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/videos/tag/">Tags</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/about-us/">About Us</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://forms.office.com/Pages/ResponsePage.aspx?id=TlyBc-0-d0WrTt-gYiae0KLqSn4LXatBuXAR729jgnhUQ0MyQUlFMEw5UTdUMVI1TDQ1M0RFNElTSC4u" target="_blank">Publish</a>
            </li>
          </ul>
        </div>
    </div>
</nav>      
<main role="main">

    <div data-type="ad" data-publisher="lqm.usergrouptv.site" data-format="728x90" data-zone="ros" class="horizontal-ad"></div>

    <div class="container mt-3 mb-3">

        <h1>
            Continuous Testing With React, Storybook, and WebdriverIO
        </h1>

        <div class="addthis_inline_share_toolbox text-right"></div>

        
        <iframe src="https://player.vimeo.com/video/237608830" width="100%" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
        


        <h2>Abstract: </h2>
        <div><p>Working in a continuous testing environment requires us to think on multiple levels about how we test our code. We have our core component library which we can sandbox and experiment with in React Storybook. We can test our components thoroughly here in *multiple browsers* to check compatibility and function. Then we assemble our components in a react app, where we implement another level of unit and functional testing. Our react app has very specific goals, which we can acceptance test through WebdriverIO (Selenium). All of this can run in the background *and* on a continuous integration server as part of our build process so we can continually iterate on our code without fear of introducing breaking changes. This tight feedback loop is key for pursuing continuous deployment and rapid delivery of code and allows us to go further with greater confidence than before. In this talk, we will walk through some tooling and explore examples of how you can implement continuous testing in your delivery lifecycle using thing like React, Redux, Storybook, Mocha, Jest, WebdriverIO, Selenium, and GO CI.</p></div>

        <h2>Speakers: </h2>
        <div>
            <ul>
                
                <li>
                    <h3>
                        <a href="/videos/category/speaker/josh-cypher">Josh Cypher</a>
                    </h3>
                    <div>
<span class="badge badge-primary">1 Recording</span>

</div>
                    <div><p>Josh Cypher is a QA Engineer at Emma, Inc. Before Emma, he spent five years as a product manager, learning to code in an effort to better understand his developers. When he took the leap into automated testing, he never looked back and has continued to apply testing principles across the whole delivery process. Josh is an avid cyclist and often commutes to work on his beloved Bianchi road bike. In his off hours, he enjoys spending time with his wife, Rachel, and his dog, Alistair. He is a board & video game enthusiast, woodworker, and an excellent campfire cook.</p></div>
                </li>
                
            </ul>            
        </div>

        <h2>Recorded At: </h2>
        <div>
            <ul>
                
                <li>
                    <a href="/videos/category/group/little-rock-tech-fest">Little Rock Tech Fest</a> 
<span class="badge badge-primary">65 Recordings</span>


                </li>
                
            </ul>            
        </div>

        <h2>Recorded on: </h2>
        <div>Oct 6, 2017</div>

        <h2>More Info: </h2>
        <div><a href="http://www.lrtechfest.com" target="_blank" >http://www.lrtechfest.com</a></div>

        <h2>Tags: </h2>
        <div>
            <ul>
                
                <li>
                    <a href="/videos/tag/testing">Testing</a> 
<span class="badge badge-primary">5 Recordings</span>


                </li>
                
            </ul>            
        </div>


    </div>


        </main>

<nav class="navbar navbar-expand-sm navbar-dark bg-dark">
    <div class="container">
        <div class="collapse navbar-collapse" id="navbarCollapse">
        <span class="navbar-text">
            &copy; UserGroup.tv 2020
        </span>
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
                <a class="nav-link" href="/privacy-policy">Privacy Policy</a>
            </li>
        </ul>
        </div>
    </div>
</nav>



<script src="/js/vendor.min.0b95d4b13b8eff7c0d7bd03abfa2dfec4c3a2691c28074f3d11165fabb257bbe8fe13a9ea0be599db9df9fb80f3bf18323f1153786cd4cb1c383b06d58ed99a1.js" integrity="sha512-C5XUsTuO/3wNe9A6v6Lf7Ew6JpHCgHTz0RFl&#43;rsle76P4TqeoL5Znbnfn7gPO/GDI/EVN4bNTLHDg7BtWO2ZoQ=="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-155341911-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script type='text/javascript'>
    function _dmBootstrap(file) {
        var _dma = document.createElement('script');
        _dma.type = 'text/javascript';
        _dma.async = true;
        _dma.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + file;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(_dma);
    }
    function _dmFollowup(file) { if (typeof DMAds === 'undefined') _dmBootstrap('cdn2.DeveloperMedia.com/a.min.js'); }
    (function () { _dmBootstrap('cdn1.DeveloperMedia.com/a.min.js'); setTimeout(_dmFollowup, 2000); })();
</script>

<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5fb843a02f2efdea"></script>
</body>
</html>
